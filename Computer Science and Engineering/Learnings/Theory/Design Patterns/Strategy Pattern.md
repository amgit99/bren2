This pattern is used when we have a set of algorithms/procedures/strategies. Also there are objects that need to implement any one/more than one of them, so we make them modular and interchangeable instead of burying them into the definition of the object. This helps especially when there are hierarchies in class structures.
![[Screenshot 2023-12-19 at 6.19.10 PM.png]]Lets the the `std::vector<T>` as an example, the class implements it's sort function, here is the place where we see the strategy pattern, there are multiple ways by which two objects in a vector can be ordered(ascending, descending, lexicographic ... may be different for more complex objects) as relative ordering of items is what gives sorting its meaning. So the std library has the sort method defined i.e it has a fixed interface. This takes, as its third and optional parameter a function that returns a bool and takes two items of class T as arguments. This function can be changed to affect the result of the the algorithm.

<span style="color:#e1db3d">Observation</span> : The strategy pattern can be used to <span style="color:#e1db3d">eliminate hierarchy</span> in classes. So if we have a parent class that has some behaviour, and it has subclasses that override some of that behaviour (using the duck example, there are various subclasses of class "Duck" because they quack and fly differently) now we can create a hierarchy where the subclasses write their own `fly()` and `quack()` methods. But if more types of subclasses are introduced that don't necessarily follow the hierarchy and want a mix of different behaviours, there will be code duplication and messy situations. To deal with this we get rid of hierarchy and have custom interfaces for places that have specific algorithms like fly and quack. So a new duck can be composed of various possible combinations that are available to us with that strategies that conform to/implement the given interfaces.
### <span style="color:#984BD2">This promotes composition over inheritance.</span> 